<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kasane Teto Tetris - 2 Player Mode</title>
  <style>
    body {
      margin: 0;
      background: #fdd0f7;
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      flex-direction: column;
      position: relative;
    }
    canvas {
      background: #fff0fb;
      border: 4px solid #ff6ec7;
      margin: 0 10px;
    }
    #scoreboard {
      width: 520px;
      display: flex;
      justify-content: space-between;
      margin: 10px 0;
      color: #c23b94;
      font-size: 20px;
      font-weight: bold;
    }
    #scoreboard div {
      width: 240px;
      text-align: center;
    }
    #gameOverScreen {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 2rem;
      text-align: center;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 10;
    }
    #gameOverScreen img {
      width: 200px;
      margin: 20px 0;
    }
    #gameOverScreen button {
      font-size: 1.2rem;
      padding: 10px 20px;
      background: #ff6ec7;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
    }
    button {
      margin: 5px;
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      color: white;
      font-weight: bold;
    }
    #showControlsBtn { background-color: #ff6ec7; }
    #pauseBtn { background-color: #a83279; }
    #startBtn { background-color: #32a852; }
    #muteBtn { background-color: #555; }
    #toggleModeBtn { background-color: #6a42a8; margin-top: 10px; }
    #controls {
      color: #c23b94;
      font-size: 16px;
      margin-bottom: 10px;
      display: none;
      width: 520px;
      display: flex;
      justify-content: space-between;
    }
    #controls div {
      width: 240px;
      text-align: center;
    }
    #boardsWrapper {
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    #tetoReactionWrapper {
      margin-left: 20px;
    }
    #tetoReaction {
      width: 150px;
      height: auto;
    }
  </style>
</head>
<body>
  <div id="scoreboard">
    <div>Player 1 Score: <span id="score1">0</span></div>
    <div>Player 2 Score: <span id="score2">0</span></div>
  </div>
  <div id="buttonsWrapper">
    <button id="showControlsBtn" onclick="toggleControls()">Show Controls</button>
    <button id="pauseBtn" onclick="togglePause()" disabled>Pause</button>
    <button id="startBtn" onclick="startGame()">Start Game</button>
    <button id="muteBtn" onclick="toggleMute()">Mute</button>
  </div>
  <div id="controls">
    <div>
      <b>Player 1 (WASD):</b><br/>
      W: Rotate | A: Left | S: Drop | D: Right
    </div>
    <div>
      <b>Player 2 (Arrow keys):</b><br/>
      ↑: Rotate | ←: Left | ↓: Drop | →: Right
    </div>
  </div>
  <div id="boardsWrapper">
    <canvas id="tetris1" width="240" height="400"></canvas>
    <canvas id="tetris2" width="240" height="400"></canvas>
    <div id="tetoReactionWrapper">
      <img
        id="tetoReaction"
        src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/53/Kasane_Teto_vector.svg/600px-Kasane_Teto_vector.svg.png"
        alt="Teto Reacting"
      />
    </div>
  </div>
  <button id="toggleModeBtn" onclick="toggleMode()">Switch to 2 Player Mode</button>
  <div id="gameOverScreen">
    <div>Game Over</div>
    <img src="https://static.zerochan.net/Kasane.Teto.full.283735.jpg" alt="Teto sad" />
    <button onclick="restartGame()">Restart</button>
  </div>

  <audio id="bgm" loop></audio>

  <script>
    // Shared constants & utilities
    const colors = {
      T: "#c23b94",
      O: "#ffc0cb",
      L: "#ff69b4",
      J: "#d87093",
      I: "#ff6ec7",
      S: "#ff1493",
      Z: "#db7093",
    };
    const pieces = "TJLOSZI";

    function createPiece(type) {
      switch (type) {
        case "T":
          return [
            [0, 0, 0],
            [1, 1, 1],
            [0, 1, 0],
          ];
        case "O":
          return [
            [2, 2],
            [2, 2],
          ];
        case "L":
          return [
            [0, 3, 0],
            [0, 3, 0],
            [0, 3, 3],
          ];
        case "J":
          return [
            [0, 4, 0],
            [0, 4, 0],
            [4, 4, 0],
          ];
        case "I":
          return [
            [0, 5, 0, 0],
            [0, 5, 0, 0],
            [0, 5, 0, 0],
            [0, 5, 0, 0],
          ];
        case "S":
          return [
            [0, 6, 6],
            [6, 6, 0],
            [0, 0, 0],
          ];
        case "Z":
          return [
            [7, 7, 0],
            [0, 7, 7],
            [0, 0, 0],
          ];
      }
    }

    function createMatrix(w, h) {
      const matrix = [];
      while (h--) matrix.push(new Array(w).fill(0));
      return matrix;
    }

    // Player class to hold all player-related states and functions
    class Player {
      constructor(canvas, scoreId) {
        this.canvas = canvas;
        this.context = canvas.getContext("2d");
        this.context.scale(20, 20);
        this.arena = createMatrix(12, 20);
        this.pos = { x: 0, y: 0 };
        this.matrix = null;
        this.score = 0;
        this.dropCounter = 0;
        this.dropInterval = 1000;
        this.dropCount = 0;
        this.speedIncreaseStep = 5;
        this.speedMultiplier = 0.9;
        this.lastTime = 0;
        this.scoreElement = document.getElementById(scoreId);
        this.breakingRows = [];
        this.breakingParticles = [];
        this.breakingDuration = 500;
        this.breakingStartTime = 0;
        this.lost = false;
      }

      reset() {
        this.matrix = createPiece(pieces[Math.floor(Math.random() * pieces.length)]);
        this.pos.y = 0;
        this.pos.x = (this.arena[0].length / 2 | 0) - (this.matrix[0].length / 2 | 0);
        if (this.collide()) {
          this.lost = true;
          return false;
        }
        this.lost = false;
        return true;
      }

      collide() {
        const m = this.matrix;
        const o = this.pos;
        for (let y = 0; y < m.length; ++y) {
          for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0 && (this.arena[y + o.y] && this.arena[y + o.y][x + o.x]) !== 0) {
              return true;
            }
          }
        }
        return false;
      }

      merge() {
        this.matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value !== 0) {
              this.arena[y + this.pos.y][x + this.pos.x] = value;
            }
          });
        });
      }

      rotate(dir = 1) {
        const m = this.matrix;
        for (let y = 0; y < m.length; ++y) {
          for (let x = 0; x < y; ++x) {
            [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
          }
        }
        if (dir > 0) m.forEach((row) => row.reverse());
        else m.reverse();
        if (this.collide()) {
          if (dir > 0) m.forEach((row) => row.reverse());
          else m.reverse();
          for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < y; ++x) {
              [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
            }
          }
        }
      }

      move(dir) {
        this.pos.x += dir;
        if (this.collide()) this.pos.x -= dir;
      }

      drop() {
        this.pos.y++;
        if (this.collide()) {
          this.pos.y--;
          this.merge();
          this.sweep();
          if (!this.reset()) {
            this.lost = true;
          }
          this.dropCount++;
          if (this.dropCount % this.speedIncreaseStep === 0) {
            this.dropInterval *= this.speedMultiplier;
            if (this.dropInterval < 100) this.dropInterval = 100;
          }
        }
        this.dropCounter = 0;
      }

      sweep() {
        let rowsToBreak = [];
        outer: for (let y = this.arena.length - 1; y >= 0; --y) {
          for (let x = 0; x < this.arena[y].length; ++x) {
            if (this.arena[y][x] === 0) continue outer;
          }
          rowsToBreak.push(y);
        }
        if (rowsToBreak.length > 0 && this.breakingRows.length === 0) {
          this.startBreakingAnimation(rowsToBreak);
        }
      }

      startBreakingAnimation(rows) {
        this.breakingRows = rows;
        this.breakingParticles = [];
        this.breakingStartTime = performance.now();

        rows.forEach((y) => {
          for (let x = 0; x < this.arena[y].length; ++x) {
            if (this.arena[y][x] !== 0) {
              this.breakingParticles.push({
                x: x,
                y: y,
                color: colors[Object.keys(colors)[this.arena[y][x] - 1]],
                dx: (Math.random() - 0.5) * 2,
                dy: -Math.random() * 3 - 1,
                size: 1,
                gravity: 0.1,
                life: 1,
              });
            }
          }
        });
      }

      animateBreaking(time) {
        const elapsed = time - this.breakingStartTime;
        if (elapsed > this.breakingDuration) {
          this.breakingRows.sort((a, b) => a - b);
          for (let i = this.breakingRows.length - 1; i >= 0; i--) {
            this.arena.splice(this.breakingRows[i], 1);
            this.arena.unshift(new Array(this.arena[0].length).fill(0));
            this.score += 10 * Math.pow(2, this.breakingRows.length - i - 1);
          }
          this.breakingRows = [];
          this.breakingParticles = [];
          this.updateScore();
          return true;
        }

        this.breakingParticles.forEach((p) => {
          p.x += p.dx * 0.1;
          p.y += p.dy * 0.1;
          p.dy += p.gravity * 0.1;
          p.life -= 0.02;
        });
        return false;
      }

      drawBreakingParticles() {
        this.breakingParticles.forEach((p) => {
          if (p.life > 0) {
            this.context.fillStyle = p.color;
            this.context.fillRect(p.x, p.y, p.size, p.size);
          }
        });
      }

      drawMatrix(matrix, offset) {
        matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value !== 0) {
              this.context.fillStyle = colors[Object.keys(colors)[value - 1]];
              this.context.fillRect(x + offset.x, y + offset.y, 1, 1);
            }
          });
        });
      }

      draw() {
        this.context.fillStyle = "#fff0fb";
        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);

        if (this.breakingRows.length > 0) {
          for (let y = 0; y < this.arena.length; y++) {
            if (!this.breakingRows.includes(y)) {
              this.drawMatrix(this.arena[y], { x: 0, y: y });
            }
          }
          this.drawBreakingParticles();
        } else {
          this.drawMatrix(this.arena, { x: 0, y: 0 });
        }
        this.drawMatrix(this.matrix, this.pos);
      }

      updateScore() {
        this.scoreElement.innerText = this.score;
      }
    }

    // Setup players
    const player1 = new Player(document.getElementById("tetris1"), "score1");
    const player2 = new Player(document.getElementById("tetris2"), "score2");

    // Game state
    let isPaused = true;
    let isMuted = false;
    let animationId;
    let mode2Player = false;

    // Background music shuffle setup (simplified with 3 songs example, add your 15!)
    const bgmSongs = [
      "https://files.catbox.moe/mjio3e.mp3",
      "https://files.catbox.moe/abc123.mp3",
      "https://files.catbox.moe/def456.mp3"
      // Add more URLs here...
    ];
    const bgm = document.getElementById("bgm");
    let lastSongIndex = -1;
    function playRandomSong() {
      let nextIndex;
      do {
        nextIndex = Math.floor(Math.random() * bgmSongs.length);
      } while (nextIndex === lastSongIndex);
      lastSongIndex = nextIndex;
      bgm.src = bgmSongs[nextIndex];
      if (!isMuted) bgm.play();
    }
    bgm.addEventListener("ended", () => playRandomSong());

    function startMusic() {
      if (!isMuted) playRandomSong();
    }
    function toggleMute() {
      isMuted = !isMuted;
      bgm.muted = isMuted;
      document.getElementById("muteBtn").textContent = isMuted ? "Unmute" : "Mute";
      if (isMuted) bgm.pause();
      else if (!isPaused) bgm.play();
    }

    // Teto reaction image handling (single image for both players)
    function setTetoMood(mood) {
      const img = document.getElementById("tetoReaction");
      if (mood === "happy") {
        img.src = "https://static.wikia.nocookie.net/vocaloid/images/d/d0/Teto_smile.png";
      } else if (mood === "sad") {
        img.src = "https://static.zerochan.net/Kasane.Teto.full.283735.jpg";
      }
    }

    // Game control functions
    function toggleControls() {
      const controls = document.getElementById("controls");
      if (controls.style.display === "none" || controls.style.display === "") {
        controls.style.display = "flex";
        document.getElementById("showControlsBtn").textContent = "Hide Controls";
      } else {
        controls.style.display = "none";
        document.getElementById("showControlsBtn").textContent = "Show Controls";
      }
    }

    function togglePause() {
      isPaused = !isPaused;
      const pauseBtn = document.getElementById("pauseBtn");
      if (!isPaused) {
        pauseBtn.textContent = "Pause";
        player1.lastTime = performance.now();
        player2.lastTime = performance.now();
        update();
        if (!isMuted) bgm.play();
      } else {
        pauseBtn.textContent = "Resume";
        bgm.pause();
        cancelAnimationFrame(animationId);
      }
    }

    function startGame() {
      if
