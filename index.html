<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kasane Teto Tetris</title>
  <style>
    body {
      margin: 0;
      background: #fdd0f7;
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      flex-direction: column;
      position: relative;
      user-select: none;
    }
    canvas {
      background: #fff0fb;
      border: 4px solid #ff6ec7;
    }
    #score {
      margin: 10px;
      font-size: 20px;
      color: #c23b94;
    }
    #gameOverScreen {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0,0,0,0.7);
      color: white;
      font-size: 2rem;
      text-align: center;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 10;
    }
    #gameOverScreen img {
      width: 200px;
      margin: 20px 0;
      border-radius: 10px;
    }
    #gameOverScreen button {
      font-size: 1.2rem;
      padding: 10px 20px;
      background: #ff6ec7;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
    }
    button {
      margin: 5px;
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      color: white;
      font-weight: bold;
    }
    #showControlsBtn { background-color: #ff6ec7; }
    #pauseBtn { background-color: #a83279; }
    #startBtn { background-color: #32a852; }
    #muteBtn { background-color: #555; }
    #controls {
      color: #c23b94;
      font-size: 16px;
      margin-bottom: 10px;
      display: none;
    }
    #buttonsWrapper {
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="buttonsWrapper">
    <button id="showControlsBtn" onclick="toggleControls()">Show Controls</button>
    <button id="pauseBtn" onclick="togglePause()" disabled>Pause</button>
    <button id="startBtn" onclick="startGame()">Start Game</button>
    <button id="muteBtn" onclick="toggleMute()">Mute</button>
  </div>
  <div id="controls">⬅️ Move Left | ➡️ Move Right | ⬇️ Drop | ⬆️ Rotate</div>
  <canvas id="tetris" width="240" height="400"></canvas>
  <div id="gameOverScreen">
    <div>Game Over</div>
    <img src="https://static.zerochan.net/Kasane.Teto.full.283735.jpg" alt="Teto sad" />
    <button onclick="restartGame()">Restart</button>
  </div>
  <audio id="bgm" loop></audio>
  <script>
    // Background music playlist (15 songs)
    const bgmSongs = [
      "https://files.catbox.moe/mjio3e.mp3",
      "https://files.catbox.moe/abc123.mp3",
      "https://files.catbox.moe/def456.mp3",
      "https://files.catbox.moe/ghi789.mp3",
      "https://files.catbox.moe/jkl012.mp3",
      "https://files.catbox.moe/mno345.mp3",
      "https://files.catbox.moe/pqr678.mp3",
      "https://files.catbox.moe/stu901.mp3",
      "https://files.catbox.moe/vwx234.mp3",
      "https://files.catbox.moe/yz1234.mp3",
      "https://files.catbox.moe/abcd567.mp3",
      "https://files.catbox.moe/efgh890.mp3",
      "https://files.catbox.moe/ijkl123.mp3",
      "https://files.catbox.moe/mnop456.mp3",
      "https://files.catbox.moe/qrst789.mp3"
    ];
    const bgm = document.getElementById('bgm');
    let lastSongIndex = -1;
    let isMuted = false;
    function playRandomSong() {
      let nextIndex;
      do {
        nextIndex = Math.floor(Math.random() * bgmSongs.length);
      } while(nextIndex === lastSongIndex);
      lastSongIndex = nextIndex;
      bgm.src = bgmSongs[nextIndex];
      if (!isMuted) {
        bgm.play();
      }
    }
    bgm.addEventListener('ended', () => {
      playRandomSong();
    });
    document.addEventListener("click", () => {
      if (bgm.paused && !isMuted) playRandomSong();
    }, {once:true});

    // Canvas & game variables
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    ctx.scale(20,20);

    const scoreElement = document.getElementById('score');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const pauseBtn = document.getElementById('pauseBtn');
    const startBtn = document.getElementById('startBtn');
    const controlsDiv = document.getElementById('controls');
    const showControlsBtn = document.getElementById('showControlsBtn');
    const muteBtn = document.getElementById('muteBtn');

    const colors = {
      0: null,
      1: '#c23b94',  // T
      2: '#ffc0cb',  // O
      3: '#ff69b4',  // L
      4: '#d87093',  // J
      5: '#ff6ec7',  // I
      6: '#ff1493',  // S
      7: '#db7093'   // Z
    };

    const pieces = 'TJLOSZI';

    function createPiece(type) {
      switch(type) {
        case 'T': return [
          [0,0,0],
          [1,1,1],
          [0,1,0]
        ];
        case 'O': return [
          [2,2],
          [2,2]
        ];
        case 'L': return [
          [0,3,0],
          [0,3,0],
          [0,3,3]
        ];
        case 'J': return [
          [0,4,0],
          [0,4,0],
          [4,4,0]
        ];
        case 'I': return [
          [0,5,0,0],
          [0,5,0,0],
          [0,5,0,0],
          [0,5,0,0]
        ];
        case 'S': return [
          [0,6,6],
          [6,6,0],
          [0,0,0]
        ];
        case 'Z': return [
          [7,7,0],
          [0,7,7],
          [0,0,0]
        ];
      }
    }

    function createMatrix(w,h) {
      const matrix = [];
      while(h--) matrix.push(new Array(w).fill(0));
      return matrix;
    }

    const arena = createMatrix(12,20);

    const player = {
      pos: {x:0, y:0},
      matrix: null,
      score: 0
    };

    let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;
    let dropCount = 0;
    const speedIncreaseStep = 5;
    const speedMultiplier = 0.9;
    let animationId = null;
    let isPaused = true;

    // Breaking animation
    let breakingRows = [];
    let breakingParticles = [];
    const breakingDuration = 500;
    let breakingStartTime = 0;

    function drawMatrix(matrix, offset) {
      matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if(value !== 0) {
            ctx.fillStyle = colors[value];
            ctx.fillRect(x + offset.x, y + offset.y, 1,1);
          }
        });
      });
    }

    function merge(arena, player) {
      player.matrix.forEach((row,y) => {
        row.forEach((value,x) => {
          if(value !== 0) {
            arena[y + player.pos.y][x + player.pos.x] = value;
          }
        });
      });
    }

    function collide(arena, player) {
      const m = player.matrix;
      const o = player.pos;
      for(let y = 0; y < m.length; ++y) {
        for(let x=0; x < m[y].length; ++x) {
          if(m[y][x] !== 0 &&
            (arena[y+o.y] && arena[y+o.y][x+o.x]) !== 0) {
            return true;
          }
        }
      }
      return false;
    }

    function playerDrop() {
      player.pos.y++;
      if(collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        arenaSweep();
        updateScore();
        playerReset();

        dropCount++;
        if(dropCount % speedIncreaseStep === 0) {
          dropInterval = dropInterval * speedMultiplier;
          if(dropInterval < 100) dropInterval = 100;
        }
      }
      dropCounter = 0;
    }

    function playerMove(dir) {
      player.pos.x += dir;
      if(collide(arena, player)) player.pos.x -= dir;
    }

    function playerReset() {
      const piece = pieces[Math.floor(Math.random()*pieces.length)];
      player.matrix = createPiece(piece);
      player.pos.y = 0;
      player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
      if(collide(arena, player)) {
        arena.forEach(row => row.fill(0));
        player.score = 0;
        updateScore();
        showGameOver();
        pauseBtn.disabled = true;
        startBtn.disabled = false;
        isPaused = true;
        cancelAnimationFrame(animationId);
        bgm.pause();
      }
    }

    function playerRotate() {
      const m = player.matrix;
      for(let y=0; y < m.length; ++y) {
        for(let x=0; x < y; ++x) {
          [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
        }
      }
      m.forEach(row => row.reverse());

      if(collide(arena, player)) {
        for(let y=0; y < m.length; ++y) m[y].reverse();
        for(let y=0; y < m.length; ++y) {
          for(let x=0; x < y; ++x) {
            [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
          }
        }
      }
    }

    // Break rows and animate blocks breaking
    function arenaSweep() {
      let rowsToBreak = [];
      outer: for(let y = arena.length -1; y >= 0; --y) {
        for(let x=0; x < arena[y].length; ++x) {
          if(arena[y][x] === 0) continue outer;
        }
        rowsToBreak.push(y);
      }
      if(rowsToBreak.length > 0 && breakingRows.length === 0) {
        startBreakingAnimation(rowsToBreak);
      }
    }

    function startBreakingAnimation(rows) {
      breakingRows = rows;
      breakingParticles = [];
      breakingStartTime = performance.now();
      rows.forEach(y => {
        for(let x=0; x < arena[y].length; ++x) {
          if(arena[y][x] !== 0) {
            breakingParticles.push({
              x: x,
              y: y,
              color: colors[arena[y][x]],
              dx: (Math.random()-0.5)*2,
              dy: -Math.random()*3-1,
              size: 1,
              gravity: 0.1,
              life: 1
            });
          }
        }
      });
    }

    function animateBreaking(time) {
      const elapsed = time - breakingStartTime;
      if(elapsed > breakingDuration) {
        breakingRows.sort((a,b) => a-b);
        for(let i = breakingRows.length-1; i >=0; i--) {
          arena.splice(breakingRows[i],1);
          arena.unshift(new Array(arena[0].length).fill(0));
          player.score += 10 * Math.pow(2, breakingRows.length - i - 1);
        }
        breakingRows = [];
        breakingParticles = [];
        updateScore();
        return true;
      }
      breakingParticles.forEach(p => {
        p.x += p.dx * 0.1;
        p.y += p.dy * 0.1;
        p.dy += p.gravity * 0.1;
        p.life -= 0.02;
      });
      return false;
    }

    function drawBreakingParticles() {
      breakingParticles.forEach(p => {
        if(p.life > 0) {
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x, p.y, p.size, p.size);
        }
      });
    }

    function updateScore() {
      scoreElement.textContent = 'Score: ' + player.score;
    }

    function draw() {
      ctx.fillStyle = '#fff0fb';
      ctx.fillRect(0,0, canvas.width, canvas.height);
      if(breakingRows.length > 0) {
        for(let y=0; y < arena.length; y++) {
          if(!breakingRows.includes(y)) {
            drawMatrix(arena[y], {x:0, y:y});
          }
        }
        drawBreakingParticles();
      } else {
        drawMatrix(arena, {x:0, y:0});
      }
      drawMatrix(player.matrix, player.pos);
    }

    function update(time=0) {
      if(!isPaused) {
        const deltaTime = time - lastTime;
        lastTime = time;
        dropCounter += deltaTime;

        if(breakingRows.length > 0) {
          const done = animateBreaking(time);
          if(!done) {
            draw();
            animationId = requestAnimationFrame(update);
            return;
          }
        } else if(dropCounter > dropInterval) {
          playerDrop();
        }
        draw();
        animationId = requestAnimationFrame(update);
      }
    }

    document.addEventListener('keydown', event => {
      if(isPaused) return;
      if(event.key === 'ArrowLeft') playerMove(-1);
      else if(event.key === 'ArrowRight') playerMove(1);
      else if(event.key === 'ArrowDown') playerDrop();
      else if(event.key === 'ArrowUp') playerRotate();
    });

    function toggleControls() {
      if(controlsDiv.style.display === 'none') {
        controlsDiv.style.display = 'block';
        showControlsBtn.textContent = 'Hide Controls';
      } else {
        controlsDiv.style.display = 'none';
        showControlsBtn.textContent = 'Show Controls';
      }
    }

    function startGame() {
      if(!isPaused) return;
      isPaused = false;
      pauseBtn.disabled = false;
      startBtn.disabled = true;
      player.score = 0;
      dropInterval = 1000;
      dropCount = 0;
      playerReset();
      updateScore();
      update();
      if(!isMuted) bgm.play();
    }

    function togglePause() {
      isPaused = !isPaused;
      if(!isPaused) {
        lastTime = performance.now();
        update();
        if(!isMuted) bgm.play();
      } else {
        bgm.pause();
        cancelAnimationFrame(animationId);
      }
    }

    function toggleMute() {
      isMuted = !isMuted;
      bgm.muted = isMuted;
      muteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
      if(isMuted) {
        bgm.pause();
      } else if(!isPaused) {
        bgm.play();
      }
    }

    function restartGame() {
      gameOverScreen.style.display = 'none';
      player.score = 0;
      dropInterval = 1000;
      dropCount = 0;
      isPaused = false;
      pauseBtn.disabled = false;
      startBtn.disabled = true;
      playerReset();
      updateScore();
      update();
      if(!isMuted) bgm.play();
    }

    function showGameOver() {
      gameOverScreen.style.display = 'flex';
    }
  </script>
</body>
</html>
